# First couple weeks of C, got AI to format my notes better.

ðŸ§µ C Syntax Cheat Sheet (Practical + Errorâ€‘Proof)
ðŸ”¢ Basic Data Types
	â€¢ int â†’ whole numbers (usually 32â€‘bit: âˆ’2,147,483,648 to +2,147,483,647)
	â€¢ float â†’ singleâ€‘precision decimal (approx 6â€“7 digits of precision)
	â€¢ double â†’ doubleâ€‘precision decimal (approx 15â€“16 digits)
	â€¢ char â†’ one byte (stores a single character or raw byte)
		â—‹ Characters use single quotes: 'A', '1', '!'
	â€¢ void â†’ no value returned / no parameters
	â€¢ long â†’ larger integer (usually 64â€‘bit)
	â€¢ Strings are not a type â†’ they are char arrays ending with '\0'
	
ðŸ“¥ Receiving Input
Using scanf
int x; scanf("%d", &x); 
Format specifiers:
	â€¢ %d â†’ int
	â€¢ %f â†’ float
	â€¢ %lf â†’ double
	â€¢ %c â†’ char
	â€¢ %s â†’ string (stops at whitespace)
	
Important:
scanf requires addresses, so always use &variable except for arrays.
Why scanf often fails
	â€¢ Stops at spaces
	â€¢ Leaves unread characters in the input buffer
	â€¢ Can overflow buffers if not careful
Use fgets for strings
void printer(void) { 
	char stri[100];
	 printf("Please enter a string: ");
	 fgets(stri, sizeof(stri), stdin); 
	printf("%s\n", stri);
 } 
fgets reads spaces, tabs, and stops at newline or buffer limit.

ðŸ§  Logical Operators
	â€¢ && â†’ AND
	â€¢ || â†’ OR
	â€¢ ! â†’ NOT
Example:
int number = 40; if (number == 40 && number < 60) printf("value: %d\n", number); 

ðŸ“¤ Printing Output
printf("Value: %d\n", x); 
Rules:
	â€¢ First argument must be a string literal, not a variable
	â€¢ Format specifier must match the variable type
	â€¢ No & needed â€” printf reads values, it doesnâ€™t write to them

ðŸ§© Declaring Functions
Basic function
int add(int a, int b) { return a + b; } 
Void function
void str(void) { int number = 1; printf("%d\n", number + number); } 
Function prototypes (forward declarations)
Used when main appears before the function definition.
void str(void); // prototype int main(void) { str(); return 0; } void str(void) { printf("Hello\n"); } 

Important corrections:
	â€¢ main must return int, not char
	â€¢ return str; is wrong â€” that returns a function pointer
	â€¢ Use return str(); if you want the functionâ€™s result
	
ðŸ§± Variables
	â€¢ Must be declared with a type
	â€¢ Uninitialized variables contain garbage memory
	â€¢ Use const for readâ€‘only values
Examples:
int number = 0;
 const int LIMIT = 100;
 char str[100] = "Hello"; // stored as char array + '\0'
 float flt = 4.0; 
long lng = 0; 

ðŸ” Flow Control
If / Else
if (x > 10) { // ... } else { // ... } 
While Loop
while (x < 10) { x++; } 
For Loop
for (int i = 0; i < 5; i++) { // runs 5 times } 
ðŸ“š Arrays
int nums[5] = {1, 2, 3, 4, 5}; char name[10] = "Alice"; 
Rules:
	â€¢ Fixed size
	â€¢ Zeroâ€‘indexed
	â€¢ Strings must have space for the null terminator ('\0')
	
ðŸ§± Pointers 
int x = 5; int *p = &x; // p stores the address of x printf("%d\n", *p); // dereference â†’ prints 5 
Key ideas:
	â€¢ &x â†’ â€œaddress of xâ€
	â€¢ *p â†’ â€œvalue stored at that addressâ€
	â€¢ Pointers are essential for arrays, strings, and dynamic memory

ðŸ“¦ Structs
Used to group related data.
struct Person { int age; char name[20]; } ; 
struct Person p = {20, "Alice"} ; 
Access fields:
printf("%d\n", p.age); 
printf("%s\n", p.name); 

ðŸ§¨ Common C Errors and How This Sheet Helps You Fix Them
â€œexpected char, got intâ€*
â†’ You used printf(result) instead of printf("%d", result).

â€œsegmentation faultâ€
â†’ Usually caused by bad pointers or writing outside array bounds.

â€œformat â€˜%dâ€™ expects argument of type â€˜intâ€™â€*
â†’ You forgot & in scanf.

â€œcontrol reaches end of nonâ€‘void functionâ€
â†’ Your function promised a return value but didnâ€™t return one.

â€œoverflow in implicit constant conversionâ€
â†’ You exceeded the range of int.

â€œinitializer-string for char array is too longâ€
â†’ Your string literal doesnâ€™t fit in the array.
